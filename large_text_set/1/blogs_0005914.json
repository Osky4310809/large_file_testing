{"organizations": [], "uuid": "a16243bf3fce30be7eb5d7da4ac1d0d6d9d6202e", "thread": {"social": {"gplus": {"shares": 49}, "pinterest": {"shares": 1}, "vk": {"shares": 0}, "linkedin": {"shares": 12}, "facebook": {"likes": 168, "shares": 168, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "security.stackexchange.com", "main_image": "https://cdn.sstatic.net/Sites/security/img/apple-touch-icon@2.png?v=497726d850f9", "site_section": "http://security.stackexchange.com//feeds", "section_title": "Recent Questions - Information Security Stack Exchange", "url": "http://security.stackexchange.com/questions/29019/are-passwords-stored-in-memory-safe", "country": "US", "domain_rank": 179, "title": "Are passwords stored in memory safe?", "performance_score": 1, "site": "stackexchange.com", "participants_count": 1, "title_full": "Are passwords stored in memory safe?", "spam_score": 0.0, "site_type": "blogs", "published": "2017-01-08T03:12:00.000+02:00", "replies_count": 0, "uuid": "a16243bf3fce30be7eb5d7da4ac1d0d6d9d6202e"}, "author": "Antoine Pinsard", "url": "http://security.stackexchange.com/questions/29019/are-passwords-stored-in-memory-safe", "ord_in_thread": 0, "title": "Are passwords stored in memory safe?", "locations": [], "entities": {"persons": [], "locations": [], "organizations": []}, "highlightText": "", "language": "english", "persons": [], "text": "16 Very comprehensive and interesting article. This shows how much security is not a cakewalk! – Antoine Pinsard Jan 14 '13 at 22:06 28 \"virtual machines and cloud computing cannot be ultimately safe\". I've always been skeptical about cloud computing. – Antoine Pinsard Jan 14 '13 at 22:07 34 There is one more point to make. Somewhere, at some time, for some length of time, the plaintext simply must reside in \"RAM\". The entire exercise becomes rather pointless if the plaintext is never exposed to anyone anywhere. The upshot is that RAM, which is ostensibly never persisted and can be flagged as \"protected\", is about as safe as you'll get within the bounds of a computer system. Your point holds, however, that memory (and OS protections of same) are only regarded as safe because the alternative is not to use computers at all. – KeithS Jan 14 '13 at 23:13 5 To minimise the exposure of the sensitive data as clear text, various languages provide wrappers that make it easier to use Operating System facilities to prevent paging out. See e.g. .Net SecureString . However, this only mitigates the problem, doesn't solve it. – skolima Jan 15 '13 at 10:52 39 +1 The OS is your friend, because if the OS is an enemy then you have utterly lost. – martin Jan 15 '13 at 13:15 up vote 43 down vote \nI think the OS do his jobs and avoid processes to access other's allocated memory. But I think this is somehow doable. \nYes, it is possible to access the memory of another process. On Windows, this amounts to having SE_DEBUG_PRIVILEGE and using ReadProcessMemory() to extract the information you want. \nYou can do the same thing from a Windows Driver, although it is a tad harder to get right due to some complications with what memory is currently paged in to the lower half. \nIn either case, you need to have access to an administrative account, or a process incorrectly assigned SE_DEBUG_PRIVILEGE , or a process with this privilege that can be persuaded to do what you need. \nSo, it comes down to ensuring nobody can escalate to obtain these privileges. More realistically, we ensure only trusted users can have these privileges. If you have access to an administrative account, you can quite easily read a password straight out of another account's processes' memory. \nUnder linux, you can achieve the same thing with ptrace() and the PTRACE_PEEK_DATA option. \nYou might ask why these functions exist in the first place? Actually, they're incredibly handy for debugging processes. Conceivably, this is something an administrator user may wish to do. By constrast, normal users should not need to and should be isolated from each other. \nThis is why people have advised, for some time, that running everything under the Administrator account is generally not a great idea. answered Jan 14 '13 at 20:29 user2213 2 Thank you for this concise explanation for both Windows and GNU/Linux (I guess this values for other Unix systems as well). – Antoine Pinsard Jan 14 '13 at 20:54 2 @AntoinePinsard yes, if they implement ptrace it is highly likely! – user2213 Jan 14 '13 at 21:04 3 On win you can read the memory of other processes running on the same user if if you don't have special privileges. – CodesInChaos Jan 14 '13 at 21:06 3 @Code true. I'm not sure any OS can defend you against yourself though! – user2213 Jan 14 '13 at 21:24 1 @Sadaluk The real problem occurs when code running under your account is not run by you. Think scripts calling into native libraries, buffer overflow exploits, ... – Michael Kjörling Jan 14 '13 at 22:19 up vote 34 down vote \nI work in the consumer electronics arena and security here is somewhat different than in the server environment. Here we have to assume that the product is in a hostile environment. So for subscriber management purposes keys are kept secure. The first line of defence is that the SoC has hidden registers that even the operating system can't actually access, they are burnt in at manufacture time and chip-fuses are blown which prevent access. Also we don't see keys ourselves because that would be insecure on the production floor, instead they are pre-packaged with a batch key that we don't know, only the chip vendor and person who created the key knows that (the master key can be destroyed after use in the chip). Once the chip is loaded with secrets then it can be locked and never* unlocked. \nIf you can't access the keys then how do you decrypt anything? With a cryptographic co-processor on the SoC you can load key positions without actually knowing the value inside. You also don't see the microcode of the crypto-processor, ever, because then even at the time of manufacture you can't inject anything. \nIf you have keys or certs that won't fit into the generous chip registers then you have to store them in RAM and/or NVM, but because of the crypto-processor you don't need to expose those values. They RAM or NVM itself can be scrambled by the chip with a key which is not known by anyone but itself. \nLastly unlike in computers, secure embedded systems also have some physical security. RAM connection tracks aren't permitted to be on the surface of the PCB (\"buried vias\"). This is because if there are elements which are in the clear in RAM then you need to limit access, it is possible to slow down or freeze the CPU and then probe the RAM. \nFinally for smart cards it has been possible to intercept the transactions between the SoC and the card. This is called \"Card sharing\", the solution to this is to encrypt the transactions between the card and the SoC and bind them to each other so they can't be swapped or shared. \nI know that DRM/content security is unpopular with some people on the interwebs, but I thought I would share some high-level concepts from an industry which has some particular security requirements. \n*In theory.", "external_links": [], "published": "2017-01-08T03:12:00.000+02:00", "crawled": "2017-01-08T00:07:08.066+02:00", "highlightTitle": ""}