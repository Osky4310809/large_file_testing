{"organizations": [], "uuid": "a0b86a0644b8c15d9a88846df403c39192a20c00", "thread": {"social": {"gplus": {"shares": 5}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 24}, "facebook": {"likes": 111, "shares": 111, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "stripe.com", "main_image": "https://stripe.com/img/v3/home/social.png", "site_section": "", "section_title": "", "url": "https://stripe.com/blog/idempotency", "country": "US", "domain_rank": 3759, "title": "Designing robust and predictable APIs with idempotency", "performance_score": 1, "site": "stripe.com", "participants_count": 0, "title_full": "Designing robust and predictable APIs with idempotency", "spam_score": 0.973, "site_type": "blogs", "published": "2017-02-23T01:27:00.000+02:00", "replies_count": 0, "uuid": "a0b86a0644b8c15d9a88846df403c39192a20c00"}, "author": "Brandur Leach", "url": "https://stripe.com/blog/idempotency", "ord_in_thread": 0, "title": "Designing robust and predictable APIs with idempotency", "locations": [], "entities": {"persons": [{"name": "brandur leach", "sentiment": "negative"}], "locations": [], "organizations": []}, "highlightText": "", "language": "english", "persons": [], "text": "\nBrandur Leach on February 22, 2017 in Engineering \nNetworks are unreliable . We’ve all experienced trouble connecting to Wi-Fi, or had a phone call drop on us abruptly. \nThe networks connecting our servers are, on average, more reliable than consumer-level last miles like cellular or home ISPs, but given enough information moving across the wire, they’re still going to fail in exotic ways. Outages, routing problems, and other intermittent failures may be statistically unusual on the whole, but still bound to be happening all the time at some ambient background rate. \nTo overcome this sort of inherently unreliable environment, it’s important to design APIs and clients that will be robust in the event of failure, and will predictably bring a complex integration to a consistent state despite them. Let’s take a look at a few ways to do that. Planning for failure \nConsider a call between any two nodes. There are a variety of failures that can occur: The initial connection could fail as the client tries to connect to a server. The call could fail midway while the server is fulfilling the operation, leaving the work in limbo. The call could succeed, but the connection break before the server can tell its client about it. \nAny one of these leaves the client that made the request in an uncertain situation. In some cases, the failure is definitive enough that the client knows with good certainty that it’s safe to simply retry it. For example, a total failure to even establish a connection to the server. In many others though, the success of the operation is ambiguous from the perspective of the client, and it doesn’t know whether retrying the operation is safe. A connection terminating midway through message exchange is an example of this case. \nThis problem is a classic staple of distributed systems, and the definition is broad when talking about a “distributed system” in this sense: as few as two computers connecting via a network that are passing each other messages. Even the Stripe API and just one other server that’s making requests to it comprise a distributed system. Making liberal use of idempotency \nThe easiest way to address inconsistencies in distributed state caused by failures is to implement server endpoints so that they’re idempotent , which means that they can be called any number of times with no harmful side effects. while guaranteeing that side effects only occur once. \nWhen a client sees any kind of error, they can converge their state by retrying the callit can ensure the convergence of its own state with the server’s by retrying, and can continue to retry until it verifiably succeeds. This fully addresses the problem of an ambiguous failure because the client knows that it can safely handle any failure using one simple technique. \nAs an example, consider the API call for a hypothetical DNS provider that enables us to add subdomains via an HTTP request: curl https://example.com/domains/stripe.com/records/s3.stripe.com \\ -X PUT \\ -d type = CNAME \\ -d value = \"stripe.s3.amazonaws.com\" \\ -d ttl = 3600 \nAll the information needed to create a record is included in the call, and it’s perfectly safe for a client to invoke it any number of times. If the server receives a call that it realizes is a duplicate because the domain already exists, it simply ignores the request and responds with a successful status code. \nIn a RESTful API, an idempotent call normally uses the PUT verb to signify that we’re replacing the target resource as opposed to simply modifying it (in modern RESTful parlance, a modification would be represented by a PATCH ). \nAccording to HTTP semantics, the PUT and DELETE verbs are idempotent , and the PUT verb in particular signifies that a target resource should be created or replaced entirely with the contents of a request’s payload (in modern RESTful parlance, a modification would be represented by a PATCH ). Guaranteeing “exactly once” semantics \nWhile the inherently idempotent HTTP semantics around PUT and DELETE are a good fit for many API calls, what if we have an operation that needs to be invoked exactly once and no more? An example might be if we were designing an API endpoint to charge a customer money; accidentally calling it twice would lead to the customer being double-charged, which is very bad. \nThis is where idempotency keys come into play. When performing a request, a client generates a unique ID to identify just that operation and sends it up to the server along with the normal payload. The server receives the ID and correlates it with the state of the request on its end. If the client notices a failure, it retries the request with the same ID, and from there it’s up to the server to figure out what to do with it. \nIf we consider our sample network failure cases from above: On retrying a connection failure, on the second request the server will see the ID for the first time, and process it normally. On a failure midway through an operation, the server picks up the work and carries it through. The exact behavior is heavily dependent on implementation, but if the previous operation was successfully rolled back by way of an ACID database, it’ll be safe to retry it wholesale. Otherwise, state is recovered and the call is continued. On a response failure (i.e. the operation executed successfully, but the client couldn’t get the result), the server simply replies with a cached result of the successful operation. \nThe Stripe API implements idempotency keys on mutating endpoints (i.e. anything under POST in our case) by allowing clients to pass a unique value in with the special Idempotency-Key header, which allows a client to guarantee the safety of distributed operations: curl https://api.stripe.com/v1/charges \\ -u sk_test_BQokikJOvBiI2HlWgH4olfQ2 : \\ -H \"Idempotency-Key: AGJ6FJMkGQIpHUTX\" \\ -d amount = 2000 \\ -d currency = usd \\ -d description = \"Charge for Brandur\" \\ -d customer = cus_A8Z5MHwQS7jUmZ \nIf the above Stripe request fails due to a network connection error, you can safely retry it with the same idempotency key, and the customer is charged only once. Being a good distributed citizen \nSafely handling failure is hugely important, but beyond that, it’s also recommended that it be handled in a considerate way. When a client sees that a network operation has failed, there’s a good chance that it’s due to an intermittent failure that will be gone by the next retry. However, there’s also a chance that it’s a more serious problem that’s going to be more tenacious; for example, if the server is in the middle of an incident that’s causing hard downtime. Not only will retries of the operation not go through, but they may contribute to further degradation. \nIt’s usually recommended that clients follow something akin to an exponential backoff algorithm as they see errors. The client blocks for a brief initial wait time on the first failure, but as the operation continues to fail, it waits proportionally to 2 n , where n is the number of failures that have occurred. By backing off exponentially, we can ensure that clients aren’t hammering on a downed server and contributing to the problem. \nExponential backoff has a long and interesting history in computer networking. \nFurthermore, it’s also a good idea to mix in an element of randomness. If a problem with a server causes a large number of clients to fail at close to the same time, then even with back off, their retry schedules could be aligned closely enough that the retries will hammer the troubled server. This is known as the thundering herd problem . \nWe can address thundering herd by adding some amount of random “jitter” to each client’s wait time. This will space out requests across all clients, and give the server some breathing room to recover. \nThundering herd problem when a server faces simultaneous retries from all clients. \nThe Stripe Ruby library retries on failure automatically with an idempotency key using increasing backoff times and jitter. The implementation for that is pretty simple, and you can refer to it on GitHub to see exactly how it works. Codifying the design of robust APIs \nConsidering the possibility of failure in a distributed system and how to handle it is of paramount importance in building APIs that are both robust and predictable. Retry logic on clients and idempotency on servers are techniques that are useful in achieving this goal and relatively simple to implement in any technology stack. \nHere are a few core principles to follow while designing your clients and APIs: \nMake sure that failures are handled consistently . Have clients retry operations against remote services. Not doing so could leave that they manage data in an inconsistent state that will lead to problems down the road. Make sure that failures are handled safely . Use idempotency and idempotency keys to allow clients to pass a unique value and retry requests as needed. Make sure that failures are handled responsibly . Use techniques like exponential backoff and random jitter. Be considerate of servers that may be stuck in a degraded state. Like this post? Join the Stripe engineering team. View Openings \nFebruary 22, 2017 ", "external_links": [], "published": "2017-02-23T01:27:00.000+02:00", "crawled": "2017-02-22T20:30:15.017+02:00", "highlightTitle": ""}