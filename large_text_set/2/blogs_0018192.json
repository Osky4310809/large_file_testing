{"organizations": [], "uuid": "583a6a71d9b28b00861b93cf9f64bd098acd0639", "thread": {"social": {"gplus": {"shares": 18}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 107}, "facebook": {"likes": 136, "shares": 136, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "blogs.msdn.microsoft.com", "main_image": "", "site_section": "https://news.ycombinator.com/rss", "section_title": "Hacker News", "url": "https://blogs.msdn.microsoft.com/typescript/2017/02/22/announcing-typescript-2-2/", "country": "US", "title": "Announcing TypeScript 2.2", "performance_score": 1, "site": "microsoft.com", "participants_count": 0, "title_full": "Announcing TypeScript 2.2", "spam_score": 0.0, "site_type": "blogs", "published": "2017-02-23T00:37:00.000+02:00", "replies_count": 0, "uuid": "583a6a71d9b28b00861b93cf9f64bd098acd0639"}, "author": "", "url": "https://blogs.msdn.microsoft.com/typescript/2017/02/22/announcing-typescript-2-2/", "ord_in_thread": 0, "title": "Announcing TypeScript 2.2", "locations": [], "entities": {"persons": [{"name": "herrington darkholme", "sentiment": "none"}, {"name": "foo", "sentiment": "none"}, {"name": "françois de campredon", "sentiment": "none"}], "locations": [], "organizations": [{"name": "json", "sentiment": "none"}, {"name": "react native", "sentiment": "none"}, {"name": "jsx", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "0 Today our team is happy to present our latest release with TypeScript 2.2!\nFor those who haven’t yet heard of it, TypeScript is a simple extension to JavaScript to add optional types along with all the new ECMAScript features. TypeScript builds on the ECMAScript standard and adds type-checking to make you way more productive through cleaner code and stronger tooling. Your TypeScript code then gets transformed into clean, runnable JavaScript that even older browsers can run. \nWhile there are a variety of ways to get TypeScript set up locally in your project, the easiest way to get started is to try it out on our site or just install it from npm: npm install -g typescript \nIf you’re a Visual Studio 2015 user with update 3, you can install TypeScript 2.2 from here . You can also grab this release through NuGet . Support in Visual Studio 2017 will come in a future update. \nIf you’d rather not wait for TypeScript 2.2 support by default, you can configure Visual Studio Code and our Sublime Text plugin to pick up whatever version you need. \nAs usual, we’ve written up about new features on our what’s new page , but we’d like to highlight a couple of them. More quick fixes \nOne of the areas we focus on in TypeScript is its tooling – tooling can be leveraged in any editor with a plugin system. This is one of the things that makes the TypeScript experience so powerful. \nWith TypeScript 2.2, we’re bringing even more goodness to your editor. This release introduces some more useful quick fixes (also called code actions ) which can guide you in fixing up pesky errors. This includes Adding missing imports Adding forgotten this. to variables Removing unused declarations Implementing abstract members \nWith just a few of these, TypeScript practically writes your code for you. \nAs you write up your code, TypeScript can give suggestions each step of the way to help out with your errors. \nExpect similar features in the future. The TypeScript team is committed to ensuring that the JavaScript and TypeScript community gets the best tooling we can deliver. \nWith that in mind, we also want to invite the community to take part in this process. We’ve seen that code actions can really delight users, and we’re very open to suggestions, feedback, and contributions in this area. The object type \nThe object type is a new type in 2.2 that matches any types except for primitive types. In other words, you can assign anything to the object type except for boolean , number , string , null , undefined , and symbol . \nobject is distinct from the {} type and Object types in this respect due to structural compatibility. Because the empty object type ( {} ) also matches primitives, it couldn’t model APIs like Object.create which truly only expect objects – not primitives. object on the other hand does well here in that it can properly reject being assigned a number . \nWe’d like to extend our thanks to members of our community who proposed and implemented the feature, including François de Campredon and Herrington Darkholme . Easier string indexing behavior \nTypeScript has a concept called index signatures . Index signatures are part of a type, and tell the type system what the result of an element access should be. For instance, in the following: interface Foo { // Here is a string index signature: [ prop : string ] : boolean ; } declare const x : Foo ; const y = x [ \" hello \" ]; \nFoo has a string index signature that says “whenever indexing with a string , the output type is a boolean .” The core idea is that index signatures here are meant to model the way that objects often serve as maps/dictionaries in JavaScript. \nBefore TypeScript 2.2, writing something like x[\"propName\"] was the only way you could make use of a string index signature to grab a property. A little surprisingly, writing a property access like x.propName wasn’t allowed. This is slightly at odds with the way JavaScript actually works since x.propName is semantically the same as x[\"propName\"] . There’s a reasonable argument to allow both forms when an index signature is present. \nIn TypeScript 2.2, we’re doing just that and relaxing the old restriction. What this means is that things like testing properties on a JSON object has become dramatically more ergonomic. interface Config { [ prop : string ] : boolean ; } declare const options : Config ; // Used to be an error, now allowed! if ( options . debugMode ) { // ... } Better class support for mixins \nWe’ve always meant for TypeScript to support the JavaScript patterns you use no matter what style, library, or framework you prefer. Part of meeting that goal involves having TypeScript more deeply understand code as it’s written today. With TypeScript 2.2, we’ve worked to make the language understand the mixin pattern. \nWe made a few changes that involved loosening some restrictions on classes , as well as adjusting the behavior of how intersection types operate . Together, these adjustments actually allow users to express mixin-style classes in ES2015, where a class can extend anything that constructs some object type. This can be used to bridge ES2015 classes with APIs like Ember.extend . \nAs an example of such a class, we can write the following: type Constructable = new ( ... args : any []) => object ; function Timestamped < BC extends Constructable >( Base : BC ) { return class extends Base { private _timestamp = new Date (); get timestamp() { return _timestamp ; } }; } \nand dynamically create classes class Point { x : number ; y : number ; constructor ( x : number , y : number ) { this . x = x ; this . y = y ; } } const TimestampedPoint = Timestamped ( Point ); \nand even extend from those classes class SpecialPoint extends Timestamped ( Point ) { z : number ; constructor ( x : number , y : number , z : number ) { super ( x , y ); this . z = z ; } } let p = new SpecialPoint ( 1 , 2 , 3 ); // 'x', 'y', 'z', and 'timestamp' are all valid properties. let v = p . x + p . y + p . z ; p . timestamp . getMilliseconds () The react-native JSX emit mode \nIn addition to the preserve and react options for JSX, TypeScript now introduces the react-native emit mode. This mode is like a combination of the two, in that it emits to .js files (like --jsx react ), but leaves JSX syntax alone (like --jsx preserve ). \nThis new mode reflects React Native’s behavior, which expects all input files to be .js files. It’s also useful for cases where you want to just leave your JSX syntax alone but get .js files out from TypeScript. Support for new.target \nWith TypeScript 2.2, we’ve implemented ECMAScript’s new.target meta-property . new.target is an ES2015 feature that lets constructors figure out if a subclass is being constructed. This feature can be handy since ES2015 doesn’t allow constructors to access this before calling super() . What’s next? \nOur team is always looking forward, and is now hard at work on TypeScript 2.3. While our team’s roadmap should give you an idea of what’s to come, we’re excited for our next release, where we’re looking to deliver default types for generics downlevel generator support \nOf course, that’s only a preview for now. \nWe hope TypeScript 2.2 makes you even more productive, and allows you to be even more expressive in your code. Thanks for taking the time to read through, and as always, happy hacking!", "external_links": [], "published": "2017-02-23T00:37:00.000+02:00", "crawled": "2017-02-22T20:08:11.784+02:00", "highlightTitle": ""}