{"organizations": [], "uuid": "64704fbd3a41ae6f63115e2deeccf175be9fd08d", "thread": {"social": {"gplus": {"shares": 2}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 83}, "facebook": {"likes": 145, "shares": 145, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "blog.xamarin.com", "main_image": "https://s3.amazonaws.com/blog.xamarin.com/wp-content/uploads/2017/03/07143719/SmoothListView.gif", "site_section": "https://blog.xamarin.com/feed", "section_title": "Xamarin Blog", "url": "https://blog.xamarin.com/getting-started-with-async-await/", "country": "US", "domain_rank": 8729, "title": "Getting Started with Async / Await", "performance_score": 1, "site": "xamarin.com", "participants_count": 1, "title_full": "Getting Started with Async / Await", "spam_score": 0.0, "site_type": "blogs", "published": "2017-03-14T03:48:00.000+02:00", "replies_count": 0, "uuid": "64704fbd3a41ae6f63115e2deeccf175be9fd08d"}, "author": "Jon Goldberger", "url": "https://blog.xamarin.com/getting-started-with-async-await/", "ord_in_thread": 0, "title": "Getting Started with Async / Await", "locations": [], "entities": {"persons": [{"name": "viewcontrollerjerky", "sentiment": "none"}], "locations": [], "organizations": [{"name": "tpl", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "return await MyMethodAsync ( ) ; // MyMethodAsync also returns Task<string> in this example } \nIn fact doing the above may cause your UI to hang completely and for the ListView never to be populated, which is a non-starter. It may also just be jerky: \nIn general, you should avoid using Wait() and Result , especially on the UI thread. In the iOS and Android sample projects linked at the end of this blog, you can look in ViewControllerJerky and MainActivityJerky respectively to see this behavior. Those files are not set to compile in the sample projects. Using Async All the Way \nSo how do I get “async all the way” in this scenario? \nOne way around the above problems is to revert to the old TPL upon which async / await is based. You’re going to use TPL directly, but only once to start the chain of async method calls (and to start a new thread right away). Somewhere down the line the TPL will be used directly again, as you need to use TPL to start a new thread. You can’t start a new thread using only the async / await keywords, so some method down the chain will have to launch the new thread with TPL (or another mechanism). The async method that launches a new thread will be a framework method, like a .NET HttpClient async method in many, if not most, cases. If not using async framework methods, then some method of yours down the chain will have to launch a new thread and return Task or Task<T> . \nLet’s start with an example using GetView in an Android project (though the same concept will work for any platform, i.e. Xamarin.iOS, Xamarin.Forms, etc.) Let’s say I have a ListView that I want to populate with text downloaded from the web dynamically (more likely one would download the whole list of strings first and then populate the list rows with the already downloaded content, but I’m downloading the strings row by row here for demonstration purposes, plus there are occasions where one may want to do it this way anyway). I certainly don’t want to block the UI thread waiting for the multiple downloads; rather, I would like the user to be able to start working with the ListView, scroll around, and have the text appear in each ListView cell as the text gets downloaded. I also want to make sure that if a cell scrolls out of view, that when it is reused it will cancel loading the text that is in the process of being downloaded and start loading new text for that row instead. We do this with TPL and cancellation tokens. Comments in the code should explain what’s being done. 1", "external_links": [], "published": "2017-03-14T03:48:00.000+02:00", "crawled": "2017-03-14T02:03:31.311+02:00", "highlightTitle": ""}