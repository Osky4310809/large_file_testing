{"organizations": [], "uuid": "d9d527ac82814d7d102f40940613bbeceddbd0c2", "thread": {"social": {"gplus": {"shares": 10}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 94}, "facebook": {"likes": 192, "shares": 7, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "blog.cloudflare.com", "main_image": "", "site_section": "", "section_title": "", "url": "http://blog.cloudflare.com/tls-1-3-overview-and-q-and-a/", "country": "US", "domain_rank": 1769, "title": "An overview of TLS 1.3 and Q&A", "performance_score": 0, "site": "cloudflare.com", "participants_count": 0, "title_full": "An overview of TLS 1.3 and Q&A", "spam_score": 0.0, "site_type": "blogs", "published": "2017-03-03T11:21:00.000+02:00", "replies_count": 0, "uuid": "d9d527ac82814d7d102f40940613bbeceddbd0c2"}, "author": "", "url": "http://blog.cloudflare.com/tls-1-3-overview-and-q-and-a/", "ord_in_thread": 0, "title": "An overview of TLS 1.3 and Q&A", "locations": [], "entities": {"persons": [{"name": "heartbleed", "sentiment": "none"}, {"name": "diffie hellman", "sentiment": "none"}], "locations": [{"name": "london", "sentiment": "none"}, {"name": "vaudenay", "sentiment": "none"}], "organizations": [{"name": "tls", "sentiment": "none"}, {"name": "psk", "sentiment": "none"}, {"name": "cbc", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "An overview of TLS 1.3 and Q&A 23 Sep 2016 \nThe CloudFlare London office hosts weekly internal Tech Talks (with free lunch picked by the speaker). My recent one was an explanation of the latest version of TLS, 1.3, how it works and why it's faster and safer. \nYou can watch the complete talk below or just read my summarized transcript. \nUpdate: you might want to watch my more recent and extended 33c3 talk instead. \nThe Q&A session is open! Send us your questions about TLS 1.3 at [email protected] or leave them in the Disqus comments below and I'll answer them in an upcoming blog post. Summarized transcript \nTo understand why TLS 1.3 is awesome, we need to take a step back and look at how TLS 1.2 works. In particular we will look at modern TLS 1.2, the kind that a recent browser would use when connecting to the CloudFlare edge. \nThe client starts by sending a message called the ClientHello that essentially says \"hey, I want to speak TLS 1.2, with one of these cipher suites\". \nThe server receives that and answers with a ServerHello that says \"sure, let's speak TLS 1.2, and I pick this cipher suite\". \nAlong with that the server sends its key share . The specifics of this key share change based on what cipher suite was selected. When using ECDHE, key shares are mixed with the Elliptic Curve Diffie Hellman algorithm. \nThe important part to understand is that for the client and server to agree on a cryptographic key, they need to receive each other's portion, or share. \nFinally, the server sends the website certificate (signed by the CA) and a signature on portions of ClientHello and ServerHello , including the key share, so that the client knows that those are authentic. \nThe client receives all that, and then generates its own key share, mixes it with the server key share, and thus generates the encryption keys for the session. \nFinally, the client sends the server its key share, enables encryption and sends a Finished message (which is a hash of a transcript of what happened so far). The server does the same: it mixes the key shares to get the key and sends its own Finished message. \nAt that point we are done, and we can finally send useful data encrypted on the connection. \nNotice that this takes two round-trips between the client and the server before the HTTP request can be transferred. And round-trips on the Internet can be slow. \nEnter TLS 1.3. While TLS 1.0, 1.1 and 1.2 are not that different, 1.3 is a big jump. \nMost importantly, establishing a TLS 1.3 connection takes one less round-trip . \nIn TLS 1.3 a client starts by sending not only the ClientHello and the list of supported ciphers, but it also makes a guess as to which key agreement algorithm the server will choose, and sends a key share for that . \n( Note: the video calls the key agreement algorithm \"cipher suite\". In the meantime the specification has been changed to disjoin supported cipher suites like AES-GCM-SHA256 and supported key agreements like ECDHE P-256. ) \nAnd that saves us a round trip, because as soon as the server selects the cipher suite and key agreement algorithm, it's ready to generate the key, as it already has the client key share. So it can switch to encrypted packets one whole round-trip in advance. \nSo the server sends the ServerHello , its key share, the certificate (now encrypted, since it has a key!), and already the Finished message. \nThe client receives all that, generates the keys using the key share, checks the certificate and Finished , and it's immediately ready to send the HTTP request, after only one round-trip. Which can be hundreds of milliseconds. \nOne existing way to speed up TLS connections is called resumption. It's what happens when the client has connected to that server before, and uses what they remember from the last time to cut short the handshake. \nHow this worked in TLS 1.2 is that servers would send the client either a Session ID or a Session Ticket . The former is just a reference number that the server can trace back to a session, while the latter is an encrypted serialized session which allows the server not to keep state. \nThe next time the client would connect, it would send the Session ID or Ticket in the ClientHello , and the server would go like \"hey, I know you, we have agreed on a key already\", skip the whole key shares dance, and jump straight to Finished , saving a round-trip. \nSo, we have a way to do 1-RTT connections in 1.2 if the client has connected before, which is very common. Then what does 1.3 gain us? When resumption is available, 1.3 allows us to do 0-RTT connections , again saving one round trip and ending up with no round trip at all. \nIf you have connected to a 1.3 server before you can immediately start sending encrypted data, like an HTTP request, without any round-trip at all, making TLS essentially zero overhead . \nWhen a 1.3 client connects to a 1.3 server they agree on a resumption key (or PSK, pre-shared key), and the server gives the client a Session Ticket that will help it remember it. The Ticket can be an encrypted copy of the PSK—to avoid state—or a reference number. \nThe next time the client connects, it sends the Session Ticket in the ClientHello and then immediately, without waiting for any round trip, sends the HTTP request encrypted with the PSK. The server figures out the PSK from the Session Ticket and uses that to decrypt the 0-RTT data. \nThe client also sends a key share, so that client and server can switch to a new fresh key for the actual HTTP response and the rest of the connection. \n0-RTT comes with a couple of caveats. \nSince the PSK is not agreed upon with a fresh round of Diffie Hellman, it does not provide Forward Secrecy against a compromise of the Session Ticket key. That is, if in a year an attacker somehow obtains the Session Ticket key, it can decrypt the Session Ticket, obtain the PSK and decrypt the 0-RTT data the client sent (but not the rest of the connection). \nThis is why it's important to rotate often and not persist Session Ticket keys (CloudFlare rotates these keys hourly). \nTLS 1.2 has never provided any Forward Secrecy against a compromise of the Session Ticket key at all, so even with 0-RTT 1.3 is an improvement upon 1.2. \nMore problematic are replay attacks. \nSince with Session Tickets servers are stateless, they have no way to know if a packet of 0-RTT data was already sent before. \nImagine that the 0-RTT data a client sent is not an HTTP GET (\"hey, send me this page\") but instead an HTTP POST executing a transaction like \"hey, send Filippo 50$\". If I'm in the middle I can intercept that ClientHello +0-RTT packet, and then re-send it to the server 100 times. No need to know any key. I now have 5000$. \nEvery time the server will see a Session Ticket, unwrap it to find the PSK, use the PSK to decrypt the 0-RTT data and find the HTTP POST inside, with no way to know something is fishy. \nThe solution is that servers must not execute operations that are not idempotent received in 0-RTT data. Instead in those cases they should force the client to perform a full 1-RTT handshake. That protects from replay since each ClientHello and ServerHello come with a Random value and connections have sequence numbers, so there's no way to replay recorded traffic verbatim. \nThankfully, most times the first request a client sends is not a state-changing transaction, but something idempotent like a GET. \nTLS 1.3 is not only good for cutting a round-trip. It's also better, more robust crypto all around. \nMost importantly, many things were removed. 1.3 marked a shift in the design approach: it used to be the case that the TLS committee would accept any proposal that made sense, and implementations like OpenSSL would add support for it. Think for example Heartbeats, the rarely used feature that cause Heartbleed . \nIn 1.3, everything was scrutinized for being really necessary and secure, and scrapped otherwise. A lot of things are gone: the CBC MAC-then-Encrypt modes , which were responsible for Vaudenay, Lucky13, POODLE, LuckyMinus20 ... replaced by AEADs weak primitives like RC4 , SHA1, MD5 compression ", "external_links": [], "published": "2017-03-03T11:21:00.000+02:00", "crawled": "2017-03-03T06:39:21.738+02:00", "highlightTitle": ""}