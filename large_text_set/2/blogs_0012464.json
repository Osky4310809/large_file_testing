{"organizations": [], "uuid": "17701320f446974f949a59c1adb5797da179203b", "thread": {"social": {"gplus": {"shares": 58}, "pinterest": {"shares": 9}, "vk": {"shares": 0}, "linkedin": {"shares": 73}, "facebook": {"likes": 244, "shares": 244, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "blog.teamtreehouse.com", "main_image": "http://blog.teamtreehouse.com/wp-content/uploads/2015/08/shutterstock_190440152.jpg", "site_section": "http://blog.teamtreehouse.com/comments/feed", "section_title": "Comments for Treehouse Blog", "url": "http://blog.teamtreehouse.com/passing-google-interview-without-computer-science-degree", "country": "US", "domain_rank": 3967, "title": "Comment on Passing the Google Interview, Without a Computer Science Degree by Hi", "performance_score": 2, "site": "teamtreehouse.com", "participants_count": 1, "title_full": "Comment on Passing the Google Interview, Without a Computer Science Degree by Hi", "spam_score": 0.0, "site_type": "blogs", "published": "2017-02-16T02:17:00.000+02:00", "replies_count": 0, "uuid": "17701320f446974f949a59c1adb5797da179203b"}, "author": "Hi", "url": "http://blog.teamtreehouse.com/passing-google-interview-without-computer-science-degree", "ord_in_thread": 0, "title": "Comment on Passing the Google Interview, Without a Computer Science Degree by Hi", "locations": [], "entities": {"persons": [], "locations": [], "organizations": []}, "highlightText": "", "language": "english", "persons": [], "text": "  Passing the Google Interview, Without a Computer Science Degree  //blog.teamtreehouse.com/passing-google-interview-without-computer-science-degree. Captcha Submit \nParker Phinney founded Interview Cake , an interactive practice tool for preparing for coding interviews. He’s focused on shining a light on the black box of the algorithm design process, showing people how to reason their way to the best solutions . If you’re interested in further developing your algorithmic thinking skills, try some of our practice programming interview questions in Java , JavaScript , or Python . \nThere’s a lot of mythos around Google’s software engineering interview questions. They’re fraught with tricky math puzzles, solvable only by geniuses who can Rain Man perfect solutions out of thin air. Unless you’re a child prodigy who built computers at age 10 and studied computer science at Stanford at age 16, you don’t stand a chance. \nWrong! The Google interview is extremely learnable, and you don’t even need a computer science degree to learn how to win. \nTo start, all you need is some general programming skills—the kind you can get on Treehouse . In this post, I’ll explain how to get from “new programmer” to “ready for the Google interview.” You don’t have to be Rain Man to pass the Google interview Understand the game \nThere’s nothing crazy or mysterious about Google interview questions. They’re just programming exercises. You can check out some practice Google interview questions for yourself. They’re not terribly different from the types of questions you get at Facebook , Amazon and most of the big-name tech companies. In fact, they aren’t terribly different from the types of questions you’ll get at most tech companies. Again, they’re just programming exercises . \nNow, that doesn’t mean they’re easy . They’re not. They’re hard. They’re hard for everyone. But if you understand the game, you can learn how to beat them. \nWhat makes Google interview questions hard is this: Google interviewers aren’t just looking for an answer, they’re looking for the best answer. \nNot only that—you need to be able to show why a certain answer is best (a lucky guess isn’t enough). This means you’ll need a vocabulary for talking about how efficiently a function solves a problem , and a method for deriving more efficient solutions. \nWhat we’re talking about here is algorithm design, and it’s the main thing most engineers without a CS degree are lacking . \nIt’s the main thing Google tests for in their interviews. But it doesn’t take 4 years to learn. More like 4 weeks . Or less. \nToday, I want to give you a taste for that algorithm design process. My goal is to prove to you that this stuff is: Totally learnable Really fun A great way to elevate your engineering craft, whether or not you want to interview at Google A sample problem \nThe best coding interview problems have 3 answers: a bad answer, a good answer, and a great answer. All 3 answers are correct —what makes each answer better than the last is how much time it takes to run . \nIn each Google interview, a candidate spends as much as an hour working aloud—with some help from her interviewer—as she tries to derive the bad answer, tweak and improve to get to the good answer, and (if she’s good!) iterate further to get to the great answer. \nThe fastest way to get a feel for this process is to look at an example, so let’s work through a problem together. As we go, I’ll share the thinking used to derive each answer , so you can see that great coding interview performance isn’t just about being lucky enough to stumble into the right blind insight. There’s a learnable process to solving these problems. \nOkay, let’s get into it. Here’s the problem: \nWrite a function that takes an array of numbers and returns the greatest difference you can get by subtracting any two of those numbers. \nFor example, if our input is [5,8,6,1] , the greatest difference we can get is 8-1, which is 7. So we should return 7 . \nLet’s solve this together. How should we get started? The first solution \nHere’s my first thought: we’re trying to find the greatest difference . So how about we find all of the possible differences, and return the greatest from among them? \nTo get every possible difference, we just need to subtract every number from every other number. We can do this by nesting two loops, with each one iterating over our input array. Here’s how that could look in Python: def get_greatest_difference(nums): greatest_difference = 0 for num1 in nums: for num2 in nums: difference = num1 - num2 if difference > greatest_difference: greatest_difference = difference return greatest_difference \nAlright, this’ll work! But how well does it work? Specifically, how long does this function take to run? \nIn algorithm design, we use a specific language for talking about run time, called big O notation . It’s a bit tricky to understand at first, but it comes together quickly with a bit of practice. It’s best learned through example, so let’s jump right in: \nWe want to know how many steps our algorithm takes as it solves the problem. In this case the question is, “how many times do we have to compute a new difference and see if it’s our new greatest_difference ?” \nWell, the outer loop runs once for each item in our input array, and the inner loop runs once for each item in our array. \nLet’s create some shorthand for “the number of items in our input array.” Let’s call that number “n.” \nSo our outer loop runs n times, and our inner loop runs n times for each iteration of the outer loop . So our inner loop runs a total of n*n, or n² times. \nSo we would say that our total run time is “order of n²” or O(n²)! The better solution \nCan we do better? Let’s see. Notice that our O(n²) run time comes from the fact we’re nesting two loops that both go through all n numbers in our array. Perhaps we can solve the problem without nesting two loops? \nThe reason we nested two loops was to look at every possible difference. Can we get the greatest difference without looking at every difference ? \nThis is the part where in a coding interview, we’d try solving a few sample inputs by hand and looking for patterns. In this case, there’s an important pattern to notice: the greatest difference is always simply the largest number minus the smallest number ! \nCan we avoid nesting two loops if we’re just looking for the largest and smallest numbers? Totally! Let’s just sort the input array; then our largest will be at the end and our smallest will be at the beginning: def get_greatest_difference(nums): sorted_nums = sorted(nums) return sorted_nums[-1] - sorted_nums[0] \nNow what’s our run time? \nIt looks like we’ve saved ourselves from needing any loops at all. But be careful: we still have to count work that’s done by the other functions we call ! In this case, our sorting function ( sorted() ) does quite a bit of work! How much work? This is where big O notation can get a bit nuanced. Sometimes we need to figure out how a utility function works in order to judge its big O time cost. This gets easier with practice. \nIt turns out that in general sorting costs O(n * log 2 (n)) time. We can just treat that as a piece of trivia for now. If you haven’t seen a logarithm since high school, don’t worry! The important thing for now is that log 2 (n) is much less than n. The best way to get an intuition for this is to look at some examples: if n is 100, log 2 (n) is ~6.6 if n is 1,000, log 2 (n) is ~9.9. if n is 10,000, log 2 (n) is ~13.29. \nSo log 2 (n) is quite small, and it grows slowly. (For more on what log 2 () means and where it comes up in algorithms, take a look at binary search .) \nThe good news is our last step—subtracting the 0th item from the last item—is so quick we don’t even count it in our big O calculation. So our total time cost for this approach is O(n * log 2 (n)). \nHow does that compare with the O(n²) of our first solution? Well, O(n²) is O(n*n). If we compare that with O(n*log 2 (n)), we can see that we’re still starting with n, but now we’re multiplying it by log 2 (n), instead of multiplying it by n. Since log 2 (n) is much smaller than n, O(n*log 2 (n)) is much smaller than O(n*n). Our new algorithm takes much less time than our first! The best solution \nCan we do even better ? Hmm. Notice that the entirety of our big O time cost comes from sorting our input array. Can we get the max and the min without sorting? \nWhat if we just looped through our array once, keeping track of the max and min “so far” as we went: def get_greatest_difference(nums): max = nums[0] min = nums[0] for num in nums: if num > max: max = num elif num < min: min = num return max - min \nThat’ll work! Now we have just one loop going through all n items in our array, giving us a total run time of O(n). \nThis loop kind of does two things—it checks if the current number is the new max and it checks if the current number is the new min. So we might be tempted to say this is O(2n). But in big O notation, we “ throw out the constants ” which includes the 2 in this case. So we’d still call this O(n). \nSo we went from an O(n²) time solution, to an O(n * log 2 (n)) one, to an O(n) one. That’s a huge savings! \nTo get a sense for how much time we saved, we could plug in some values or n. Suppose our input array was huge (as is often the case at large-scale tech companies like Google), and our O(n)-time solution took 4 hours to run…then our O(n²) solution might take order of 4²=16 hours to run! We saved 12 hours! Not just the Google interview \nWithout any knowledge of how to think about run time, we might look at these 3 solutions to this problem and say, “Each one is a beautiful unique snowflake that correctly solves the problem.” But our final solution is much faster than the others, especially for very large inputs. This is the power of algorithm design! \nWhether or not you’re interviewing for a job at Google, algorithmic thinking like this will dramatically enhance your software engineering skills . With just a bit of practice, you can get to a point where whenever you write code, there’s a background process in your head that’s thinking about the run time implications of what you’re doing and brainstorming optimizations. This is the beginning of the path to going from a good engineer to a great engineer!", "external_links": [], "published": "2017-02-16T02:17:00.000+02:00", "crawled": "2017-02-16T00:13:11.468+02:00", "highlightTitle": ""}