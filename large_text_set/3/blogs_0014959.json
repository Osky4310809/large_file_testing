{"organizations": [], "uuid": "67797bf7a0e5f825c8384fad46e92bfcf124407d", "thread": {"social": {"gplus": {"shares": 6}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 4}, "facebook": {"likes": 129, "shares": 129, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "www.sitepoint.com", "main_image": "https://www.sitepoint.com/wp-content/themes/sitepoint/assets/images/icon.html-css.png", "site_section": "http://www.sitepoint.com/blogs/feed/", "section_title": "SitePoint", "url": "https://www.sitepoint.com/css-architecture-css-file-organization/", "country": "US", "domain_rank": 1430, "title": "CSS Architecture: CSS File Organization", "performance_score": 1, "site": "sitepoint.com", "participants_count": 1, "title_full": "CSS Architecture: CSS File Organization", "spam_score": 0.0, "site_type": "blogs", "published": "2017-03-21T13:00:00.000+02:00", "replies_count": 0, "uuid": "67797bf7a0e5f825c8384fad46e92bfcf124407d"}, "author": "Tiffany Brown", "url": "https://www.sitepoint.com/css-architecture-css-file-organization/", "ord_in_thread": 0, "title": "CSS Architecture: CSS File Organization", "locations": [], "entities": {"persons": [{"name": "addy osmani", "sentiment": "none"}, {"name": "william chan", "sentiment": "none"}, {"name": "python", "sentiment": "none"}, {"name": "tiffany brown", "sentiment": "none"}, {"name": "anna debenham", "sentiment": "none"}], "locations": [], "organizations": [{"name": "tiffany brown", "sentiment": "negative"}, {"name": "filament group", "sentiment": "none"}, {"name": "php", "sentiment": "none"}, {"name": "css", "sentiment": "none"}, {"name": "css optimization  concatenation", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "By Tiffany Brown March 20, 2017 \nThe following is an extract from our book, CSS Master , written by Tiffany Brown. Copies are sold in stores worldwide, or you can buy it in ebook form here . CSS File Organization \nPart of a good CSS architecture is file organization. A monolithic file is fine for solo developers or very small projects. For large projects—sites with multiple layouts and content types, or multiple brands under the same design umbrella—it’s smarter to use a modular approach and split your CSS across multiple files. \nSplitting your CSS across files makes it easier to parcel tasks out to teams. One developer can work on typography-related styles, while another can focus on developing grid components. Teams can split work sensibly and increase overall productivity. \nSo what might a good file structure that splits the CSS across files look like? Here’s a structure similar to ones I’ve used in recent projects: More from this author reset.css: reset and normalization styles; minimal color, border, or font-related declarations typography.css: font faces, weights, line heights, sizes, and styles for headings and body text layouts.css: styles that manage page layouts and segments, including grids forms.css: styles for form controls and labels lists.css: list-specific styles carousel.css: styles required for carousel components accordion.css: styles for accordion components \nIf you’re using a preprocessor, such as Sass or Less, you may also want to include a _config.scss or _config.less file that contains color variables and the like. \nIn this structure, each CSS file has a specific and narrow scope. How many files you’ll ultimately end up with depends on how many visual patterns or components are called for by your site’s design. \nCSS frameworks such as Foundation and Bootstrap use this approach. Both become quite granular with separate files for progress bars, range inputs, close buttons, and tooltips. This allows developers to include only the components that they need for a project. Note: Pattern Libraries \nA closely related concept to splitting CSS across files like this is the pattern library . A great primer on the subject is Anna Debenham’s “Getting Started with Pattern Libraries.” How many files? \nEven though we’re using several CSS files for development, we’re not going to serve all of them to the browser in this form. The number of HTTP requests that we’d require would make our site take lonegr to load. Instead, we’ll concatenate our smaller CSS files into a few larger ones for production. \nConcatenation in this context, means combining multiple files into a single CSS payload. It eliminates the need for @import statements or multiple link elements. Current browsers have limits on how many files they can download at once. We can use concatenation to reduce the number of network requests, getting your content to users in less time. \nOften your web development framework will handle concatenation as part of its asset management features, such as Ruby on Rails. Some content management systems do the same, whether as a core feature or an add-on. Preprocessors—introduced in Chapter 9 also make concatenation easy. If neither preprocessors nor development frameworks are part of your workflow, chances are that your operating system has a concatenation utility that you can use instead. \nFor Mac OS X or Linux, concatenate files using the cat utility: cat file1.css file2.css > combined-output-file.css \nUsing Windows? Try the type utility: type file1.css file2.css > combined-output-file.css \nYou can also write your own concatenation script using Bash, PHP, Python, or another scripting language of your choice. Note: CSS Optimization \nConcatenation is one aspect of CSS optimization. It’s just as important to minify your files to remove excess characters and whitespace. Minification tools are covered in Chapter 3. \nSo how many files should you use? That’s where it gets tricky. The current best practice is to identify your critical path CSS—the minimum amount of CSS your page needs to render—and embed it in your pages using the style element. Additional CSS files should be loaded using JavaScript. Addy Osmani’s presentation “CSS Performance Tooling” provides an excellent overview of this technique and some tools you can use to implement it. Also see the Filament Group’s loadCSS. \nIf your content will be served using the SPDY or HTTP/2 protocols, concatenation may be unnecessary. With HTTP/1.1, browsers download assets sequentially; the next request begins when the previous one ends. Under that model, reducing the number of network requests improves site performance; however, SPDY and HTTP/2, can download multiple assets at once. As a result, there is no real benefit to reducing the number of requests. There is, however, a cost to sending more bytes than necessary to render the page. William Chan’s “HTTP/2 Considerations and Tradeoffs” explains this in greater detail. The best approach would be to identify if your server is serving HTTP/2 and, if so, check whether more of you users will benefit from actually splitting your assets down and only loading that which the page needs, or continuing to work in the old way. If you’re interested in learning more about performance optimization methods, the SitePoint book Lean Websites is a useful resource. More:", "external_links": [], "published": "2017-03-21T13:00:00.000+02:00", "crawled": "2017-03-21T12:26:16.757+02:00", "highlightTitle": ""}