{"organizations": [], "uuid": "4bdc8b28a79d0a1ad36d2926de276cda84585d27", "thread": {"social": {"gplus": {"shares": 1}, "pinterest": {"shares": 0}, "vk": {"shares": 0}, "linkedin": {"shares": 27}, "facebook": {"likes": 394, "shares": 394, "comments": 1}, "stumbledupon": {"shares": 0}}, "site_full": "www.c-sharpcorner.com", "main_image": "http://www.c-sharpcorner.com/Images/csharp-corner.png", "site_section": "http://www.asp.net/rss/dailyarticles", "section_title": "ASP.NET Articles of the Day", "url": "http://www.c-sharpcorner.com/article/onion-architecture-in-asp-net-core-mvc/", "country": "US", "domain_rank": 5225, "title": "Onion Architecture In ASP.NET Core MVC", "performance_score": 3, "site": "c-sharpcorner.com", "participants_count": 0, "title_full": "Onion Architecture In ASP.NET Core MVC", "spam_score": 0.0, "site_type": "blogs", "published": "2017-02-16T19:24:00.000+02:00", "replies_count": 0, "uuid": "4bdc8b28a79d0a1ad36d2926de276cda84585d27"}, "author": "", "url": "http://www.c-sharpcorner.com/article/onion-architecture-in-asp-net-core-mvc/", "ord_in_thread": 0, "title": "Onion Architecture In ASP.NET Core MVC", "locations": [], "entities": {"persons": [], "locations": [], "organizations": [{"name": "poco", "sentiment": "none"}, {"name": "dependency inversion principle", "sentiment": "none"}, {"name": "entity framework core", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "UI (Web/Unit Test) Layer \nFigure 1: Onion Architecture Layers These layers are towards to center. The center part is the Domain entities which represent the business and behavior objects. These layers can vary but the domain entities layer is always part of the center. The other layer defines more behavior of an object. Let’s see each layer one by one. Domain Entities Layer It is the center part of the architecture. It holds all application domain objects. If an application is developed with ORM entity framework then this layer holds POCO classes (Code First) or Edmx (Database First) with entities. These domain entities don't have any dependencies. Repository Layer The layer is intended to create an Abstraction layer between the Domain entities layer and Business Logic layer of an application. It is a data access pattern that prompts a more loosely coupled approach to data access. We create a generic repository, which queries the data source for the data, maps the data from the data source to a business entity and persists changes in the business entity to the data source. Service Layer The layer holds interfaces which are used to communicate between the UI layer and repository layer. It holds business logic for an entity so it’s called business logic layer as well. UI Layer It’s the most external layer. It could be the web application, Web API or Unit Test project. This layer has an implementation of the Dependency Inversion Principle so that application builds a loosely coupled application. It communicates to internal layer via interfaces. \nOnion Architecture Project Structure To implement the Onion architecture, we develop an ASP.NET Core application. This application performs CRUD operations on entities. The application holds four projects as per figure 2. Each project represents a layer in onion architecture. Figure 2: Application projects structure There are four projects in which three are class library projects and one is web application project. Let’s see each project mapping with onion architecture layers. OA.Data It is a class library project. It holds POCO classes along with configuration classes. It represents the Domain Entities layer of the onion architecture. These classes are used to create database tables. It’s a core and central part of the application. OA.Repo It is a second class library project. It holds generic repository class with its interface implementation. It also holds DbContext class. The Entity Framework Code First data access approach needs to create a data access context class that inherits from the DbContext class. This project represents the Repository layer of the onion architecture. OA.Service It is a third class library project. It holds business logic and interfaces. These interfaces communicate between UI and data access logic. As it communicates via interfaces, it builds applications that are loosely coupled. This project represents the Service layer of the onion architecture. OA.Web It is an ASP.NET Core Web application in this sample but it could be Unit Test or Web API project. It is the most external part of an application by which the end user can interact with the application. It builds loosely coupled applications with in-built dependency injection in ASP.NET Core. It represents the UI layer of the onion architecture. \nImplement Onion Architecture To implement the Onion Architecture in the ASP.NET Core application, create four projects as described in the above section. These four projects represent four layers of the onion architecture. Let’s see each one by one. Domain Entities Layer The Entities Domain layer is a core and central part of the architecture. So first, we create \"OA.Data\" project to implement this layer. This project holds POCO class and fluent API configuration for this POCO classes. There is an unsupported issue of EF Core 1.0.0-preview2-final with \"NETStandard.Library\": \"1.6.0\". Thus, we have changed the target framework to netstandard1.6 > netcoreapp1.0. We modify the project.json file of OA.Data project to implement the Entity Framework Core in this class library project. Thus, the code snippet, mentioned below, is used for the project.json file after modification. {", "external_links": [], "published": "2017-02-16T19:24:00.000+02:00", "crawled": "2017-02-16T17:05:37.412+02:00", "highlightTitle": ""}