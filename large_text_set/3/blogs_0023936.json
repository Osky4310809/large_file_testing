{"organizations": [], "uuid": "38f67680066aeaf9abd0586f7d716432fe6e8903", "thread": {"social": {"gplus": {"shares": 7}, "pinterest": {"shares": 0}, "vk": {"shares": 1}, "linkedin": {"shares": 0}, "facebook": {"likes": 174, "shares": 174, "comments": 0}, "stumbledupon": {"shares": 0}}, "site_full": "code.blender.org", "main_image": "", "site_section": "http://code.blender.org/feed", "section_title": "Blender Code", "url": "https://code.blender.org/2017/03/eevee-roadmap/", "country": "NL", "domain_rank": 9978, "title": "Eevee Roadmap", "performance_score": 1, "site": "blender.org", "participants_count": 1, "title_full": "Eevee Roadmap", "spam_score": 0.0, "site_type": "blogs", "published": "2017-03-22T17:42:00.000+02:00", "replies_count": 0, "uuid": "38f67680066aeaf9abd0586f7d716432fe6e8903"}, "author": "dalai", "url": "https://code.blender.org/2017/03/eevee-roadmap/", "ord_in_thread": 0, "title": "Eevee Roadmap", "locations": [], "entities": {"persons": [{"name": "hemi", "sentiment": "none"}, {"name": "eevee", "sentiment": "none"}, {"name": "python", "sentiment": "none"}, {"name": "andy goralczyk", "sentiment": "none"}], "locations": [{"name": "siggraph", "sentiment": "none"}, {"name": "eevee", "sentiment": "none"}], "organizations": [{"name": "uniform buffer object", "sentiment": "none"}, {"name": "blender institute", "sentiment": "none"}, {"name": "pbr", "sentiment": "none"}, {"name": "ubo", "sentiment": "none"}]}, "highlightText": "", "language": "english", "persons": [], "text": "by dalai on Mar 22, 2017 • 11:42 16 Comments \nIn the last post about the Viewport Plan of Action we ended briefly covering the upcoming realtime engine of Blender 2.8, nicknamed Eevee. Eevee will follow the (game) industry PBR (Physically Based Rendering) trend, supporting high-end graphics coupled with a responsive realtime viewport. \nSci-fi armor by Andy Goralczyk – rendered in Cycles with outline selection mockup, reference for PBR \nAt the time it was a bit early to discuss the specifics of the project. Time has passed, the ideas matured, and now is time to openly talk about the Eevee Roadmap. Scene Lights \nThe initial goal is to support all the realistic Blender light types (i.e., all but Hemi). \nWe will start by supporting diffuse point lights. Unlike the PBR branch, we will make sure adding/removing lights from scene doesn’t slow things down. For the tech savy: we will use UBO (Uniform Buffer Object) with the scene light data to prevent re-compiling the shaders. \nNext we can support specularity in the shaders, and expand the light support to include area lights. The implementation implies we expands the GGX shader to account for the UBO data. \nWe will also need to rework the light panels for the Eevee settings since not all settings make sense for realtime. Soft shadow \nWe all like our shadows smooth as a baby butt. But realistic smooth shadows are computationally expensive. For the realtime mode of Eevee we will follow the shadow buffer implementation we have in Blender now. For offline Eevee rendering (i.e., playblast) we can crank that up and raise the bar. Regular Materials Uber Shaders \nThings are lit and well, but we still need materials to respond to it. \nWe will implement the concept of Uber shaders following the Unreal Engine 4 PBR materials. Since Eevee goal is not feature parity with UE4, don’t expect to see all the UE4 uber shaders here (car coating, human skin, …). \nAn Uber shader is mainly an output node. For this to work effectively we also need to implement the PyNode Shader system. This way each (Python) Node can have its own GLSL shader to be used by the engine. UI/UX solution for multi-engine material outputs \nMultiple engines, one material, what to do? \nA material that was setup for Cycles and doesn’t have yet an Eevee PBR Node should still work for Eevee, even if it looks slightly different. So although we want to support Eevee own output nodes, we plan to have a fallback solution where other engine nodes are supported (assuming their nodes follow the PyNode Shader system mentioned above). Convert / Replace Blender Internal \nAfter we have a working pipeline with Eevee we should tackle compatibility of old Blender Render files. That said, the Cycles fallback option should be enough to get users to jump into Eevee from early on. Advanced Materials \nMore advanced techniques will be supported later, like: SSS Volumetric Image Based Lighting \nWe will support pre-rendered HDRI followed by in-scene on-demand generated probes. This makes the scene objects to influence each other (reflections, diffuse light bounce, …). \nWe need the viewport to always be responsive, and to have something to show while probes are calculated. Spherical harmonics (i.e., diffuse only) can be stored in the .blend for quick load while probes are generated. \nTime cache should also be considered, for responsiveness. Glossy rough shaders \nAgent 327 Barbershop project by Blender Institute – rendered in Cycles, reference of Glossy texture in wood floor \nWe can’t support glossy with roughness reflections without prefiltering (i.e., blurring) probes. Otherwise we get a terrible performance (see PBR branch :/), and a very noisy result. Diffuse approximation \nVisual representations of the first few real spherical harmonics, from wikipedia \nThere are multiple ways to represent the irradiance of the scene, such as cubemaps and spherical harmonics. \nThe more accurate way is to use a cubemap to store the result of the diffuse shader. However this is slow since it requires computing the diffusion for every texels. \nA known compromise is to store low frequency lighting informations into a set of coefficients (as known as Spherical Harmonics). Although this is faster (and easy to work with) it fails in corner cases (when lights end up cancelling themselves). \nEevee will support spherical harmonics, leaving cubemaps solely for baked specular results. Probe Objects \nLike force fields, probe should be empty objects with their own drawing code. Environment map array \nReference image from Unreal Engine 4, room design by NasteX \nLarge objects (such as floor) may need multiple probes to render the environment correctly. In Unreal environment map array handles this on supported hardware. This is not compatible with OpenGL 3.3 core. We can still support this (via ARB extension) on modern graphic cards. But we should look at alternatives compatible with old and new hardware, such as tetrahedral maps. Post Process Effects \nFor the Siggraph deadline we need the following effects: Motion Blur", "external_links": [], "published": "2017-03-22T17:42:00.000+02:00", "crawled": "2017-03-24T03:07:41.380+03:00", "highlightTitle": ""}